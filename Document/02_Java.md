#3 Java 기본 문법 , 응용

**** 굉장히 중요함 *** “APIE"
- Abstraction 추상화 -> 현실의 객체를 추상화하여 클래스를 구성한다.
- Polymorphism 다형성 -> 하나의 객체를 여러 타입으로 참조할 수 있다.
- Inheritance 상속 -> 부모 클래스의 자산을 물려받아 자식을 정의함으로 코드 재사용 가능
- Encapsulation 데이터 은닉 보호 -> 데이터를 외부에 노출x, 메서드를 이용해 보호 가능

1. Inheritance : 상속
	- 기존 클래스의 자산(멤버)을 자식 클래스에서 재사용하기 위한 것
		(부모의 생성자와 초기화 블록은 상속 X)
	- 기존 클래스의 멤버를 물려 받기 때문에 코드 절감 효과
		(부모의 코드를 변경하면 모든 자식들에게 적용 -> 유지 보수성 향상)
	- 상속의 적용 (extends 키워드 적용)

* Object 클래스 : 모든 클래스의 조상 클래스 , 별도의 extends 선언이 없는 클래스들은 extends Object가 생략 , 따라서 모든 클래스는 Object 클래스에 정의된 메소드가 있음.

*상속 관계는 is a 관계이다. ( Person is a Object ,  SpiderMan is a Person)

*단일 상속(Single Inheritance) - 다중상속의 경우 여러 클래스 기능을 상속받지만 관계가 복잡 (동일한 이름의 메서드가 두 부모에게 있다면 어떤 메서드를 쓸것인가????)
->>>> 자바는 단일 상속만 지원 (Interface화 has a (포함관계) 로 단점을 극복)

* 포함관계
        - 상속 이외에 클래스를 재활용 하는 방법. 
	2개 이상의 클래스에서 특성을 가져올 때 하나는 상속 , 나머지는 멤버 변수로 처리!
	- 어떤 클래스를 상속 / 포함 하는지는 프로젝트의 관점 문제

***
메서드 오버라이딩 (Mehtod Overriding) -> 기능 수정. +@
	- 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것.

오버라이딩의 조건 
	- 메서드 이름이 같아야 한다.
	- 매개 변수의 개수, 타입 ,  순서가 같아야한다.
	- 리턴 타입이 같아야한다.
	- 접근 제한자는 부모보다 범위가 넓거나 같아야한다.
	- 조상보다 더 큰 예외를 던질 수 없다.

메서드 오버로드의 경우 인스턴스에 따른 추가 메소드 작성 / 라이드는 추가 기능(+@) 수정
* Annotation
- 사전적 의미 : 주석
- 컴파일러 , JVM , 프레임워크 등이 보는 주석
- 소스 코드에 메타 데이터를 삽입하는 형태
	- 소스 코드에 붙여놓은 라벤
	- 코드에 대한 정보 추가 -> 코드의 구조 변경, 환경 설정 정보 추가 작업 진행


* Object 클래스 -> 가장 최상위 클래스로 모든 클래스의 조상 , Object의 멤버는 모든 클래스의 멤버.

* Equals 메서드 : 두 객체가 같은지를 비교하는 메서드
* 두 개의 레퍼런스 변수가 같은 객체를 가리키고 있는가????

*Super 키워드 
	- this를 통해 멤버에 접근 했듯이 super를 통해 조상 클래스 멤버 접근
	- super.을 이용해 조상의 메서드 호출로 조상의 코드 재사용 가능.

* this() 가 해당 클래스의 다른 생성자를 호출하듯이 super()는 조상 클래스의 생성자 호출
- 조상 클래스에 선언된 멤버들은 조상 클래스의 생성자에서 초기화 -> 재활용 가능
- 자식 클래스에 선언된 멤버들만 자식 클래스 생성자에서 초기화

*super() 는 자식 클래스 생성자의 맨 첫줄에서만 호출가능
- 즉 생성자의 첫 줄에만 this() 또는 super() 가 올 수 잇다.

* 명시적으로 this() 또는 super() 를 호출하지 않는 경우 컴파일러가 super()삽입
- 결론적으로 맨 상위의 Object 까지 객체가 다 만들어지는 구조.



2. Package & import

*Package : 프로그램의 많은 클래스 -> 패키지 이용
*import : 다른 패키지에 선언된 클래스를 사용하기 위함.

3. acess modifier & Encapsulation

*제한자 (modifier) : 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적인 의미 부여
종류 : 접근 제한자 (public , protected ,private, ) 
	그 외 static , final ,abstract ,synchronized 
하나의 대상에 여러 제한자를 조합 가능하나 접근 제한자는 하나만 가능.
순서는 무관.

* Access modidfier : 멤버등에 사용되며 해당 요소를 외부에서 사용할 수 있는지 결정

* Encapsulation -> 변수는 private접근으로 막기 , 공개되는 메서드를 통한 접근 통로 마련
( getter/ setter) -> 메서드에 정보 보호 로직 작성.

객체의 생성 제어와 Singleton 디자인 패턴
- 객체의 생성을 제한해야 한다면??? 
	- 여러개의 객체가 필요없는 경우
		- 객체를 구별할 필요가 없는 경우:수정 가능 멤버 변수X, 기능만 O
		- stateless 한 객쳋
	- 객체를 계속 생성/삭제 하는데 많은 비용이 들어 재사용성 유리

* Singleton 디자인 패턴
- 오이부에서 생성자 접근 금지 -> 생성자의 접근 제한자를 private
- 내부에서는 private에 접근 가능하므로 직접 객체 생성 -> 멤버 변수이므로 private
- 외부에서 private member에 접근 가능한 getter 생성 -> setter 불필요
- 객체 없이 외부에서 접근할 수 있도록 getter와 변수에 static 추가
- 외부에서는 언제나 getter를 통해 객체를 참조하므로 하나의 객체 재사용

4 polymorphism (****매우중요!!!!**** )
- 하나의 객체가 많은 타입(형)을 가질 수 있는 성질!!
- 상속관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 참조할 수 있음!

- 다형성의 활용 예시
	- 1. 다른 타입의 객체를 다루는 배열.	
		- 배열의 특징 : 같은 타입의 데이터를 묶음으로 다룬다.
		- 다형성으로 다른 타입의 데이터를 하나의 배열으로 관리 가능
		- Object 는 모든 클래스의 조상! -> Object배열은 전부 저장 가능해!
		- 자바의 자료구조를 간편하게 처리할 수 있음.
		- 이와 같은 특성을 이용하여 Collection API가 등장!
		** 기본형은 담을 수 있음 (내부적으로 wrapper class로 변경 후 저장됨)

	-2. 매개 변수의 다양성
		- 무언가를 출력 할 때 : 조상을 파라미터로 처리하면 객체 타입별 메서드X
		- API에서 파라미터로 Object를 받는다?? -> 모든 객체를 처리한다.
		- 필요하다면 하위 클래스에서 오버라이딩 필요함

	- 다형성과 참조형 객체의 형 변환
		- 메모리에 있는 것과 사용할 수 있는것의 차이.
		- 메모리에 있더라도 참조하는 변수 타입에 따라 접근 내용이 제한됨.
	- 참조형 객체의 형 변환
		- 자손타입의 객체를 조상 타입으로 참조 : 형변환 생략 가능(묵시적)
		- 조상타입을 자손타입으로 참조 :  명시적 형변환 필요
		*** 잘못된 형변환을 피하기 위해 boolean 타입 instanceof 연산자 사용

	- 참조변수의 레벨에 따른 객체의멤버 연결
		- 상속 관계에서 멤머 변수가 중복 될 때 : 참조변수의 타입에 따라 달라짐
	- 상속 관계에서 객체의 메서드가 중복 될 때 (메서드 오버라이딩)
		- 무조건 자식 클래스의 메서드가 호출됨 -> 최적화된 메서드 동작

* Object 클래스의 equals 메서드와 hashcode
	- equals 메서드 : 두 객체가 같은지를 비교하는 메서드 ( 두 객체의 주소값 비교)
	- 두 개의 레퍼런스가 같은 객체를 가르키고 있는가 -> 값만 같다고 같은 객체는 아님! 
	- HashCode : 시스템에서 객체를 구별하기 위해 사용하는 정수 값.
	- HashSet , HashMap 등에서 객체의 동일성을 확인하기 위해 사용
